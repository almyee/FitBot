{"ast":null,"code":"// minimal multi-purpose interface\n\n// @requires utils color analyze\nimport chroma from '../chroma.js';\nimport { limit, type } from '../utils/index.js';\nconst {\n  pow\n} = Math;\nexport default function (colors) {\n  // constructor\n  let _mode = 'rgb';\n  let _nacol = chroma('#ccc');\n  let _spread = 0;\n  // const _fixed = false;\n  let _domain = [0, 1];\n  let _pos = [];\n  let _padding = [0, 0];\n  let _classes = false;\n  let _colors = [];\n  let _out = false;\n  let _min = 0;\n  let _max = 1;\n  let _correctLightness = false;\n  let _colorCache = {};\n  let _useCache = true;\n  let _gamma = 1;\n\n  // private methods\n\n  const setColors = function (colors) {\n    colors = colors || ['#fff', '#000'];\n    if (colors && type(colors) === 'string' && chroma.brewer && chroma.brewer[colors.toLowerCase()]) {\n      colors = chroma.brewer[colors.toLowerCase()];\n    }\n    if (type(colors) === 'array') {\n      // handle single color\n      if (colors.length === 1) {\n        colors = [colors[0], colors[0]];\n      }\n      // make a copy of the colors\n      colors = colors.slice(0);\n      // convert to chroma classes\n      for (let c = 0; c < colors.length; c++) {\n        colors[c] = chroma(colors[c]);\n      }\n      // auto-fill color position\n      _pos.length = 0;\n      for (let c = 0; c < colors.length; c++) {\n        _pos.push(c / (colors.length - 1));\n      }\n    }\n    resetCache();\n    return _colors = colors;\n  };\n  const getClass = function (value) {\n    if (_classes != null) {\n      const n = _classes.length - 1;\n      let i = 0;\n      while (i < n && value >= _classes[i]) {\n        i++;\n      }\n      return i - 1;\n    }\n    return 0;\n  };\n  let tMapLightness = t => t;\n  let tMapDomain = t => t;\n\n  // const classifyValue = function(value) {\n  //     let val = value;\n  //     if (_classes.length > 2) {\n  //         const n = _classes.length-1;\n  //         const i = getClass(value);\n  //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n  //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n  //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n  //     }\n  //     return val;\n  // };\n\n  const getColor = function (val, bypassMap) {\n    let col, t;\n    if (bypassMap == null) {\n      bypassMap = false;\n    }\n    if (isNaN(val) || val === null) {\n      return _nacol;\n    }\n    if (!bypassMap) {\n      if (_classes && _classes.length > 2) {\n        // find the class\n        const c = getClass(val);\n        t = c / (_classes.length - 2);\n      } else if (_max !== _min) {\n        // just interpolate between min/max\n        t = (val - _min) / (_max - _min);\n      } else {\n        t = 1;\n      }\n    } else {\n      t = val;\n    }\n\n    // domain map\n    t = tMapDomain(t);\n    if (!bypassMap) {\n      t = tMapLightness(t); // lightness correction\n    }\n    if (_gamma !== 1) {\n      t = pow(t, _gamma);\n    }\n    t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n    t = limit(t, 0, 1);\n    const k = Math.floor(t * 10000);\n    if (_useCache && _colorCache[k]) {\n      col = _colorCache[k];\n    } else {\n      if (type(_colors) === 'array') {\n        //for i in [0.._pos.length-1]\n        for (let i = 0; i < _pos.length; i++) {\n          const p = _pos[i];\n          if (t <= p) {\n            col = _colors[i];\n            break;\n          }\n          if (t >= p && i === _pos.length - 1) {\n            col = _colors[i];\n            break;\n          }\n          if (t > p && t < _pos[i + 1]) {\n            t = (t - p) / (_pos[i + 1] - p);\n            col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);\n            break;\n          }\n        }\n      } else if (type(_colors) === 'function') {\n        col = _colors(t);\n      }\n      if (_useCache) {\n        _colorCache[k] = col;\n      }\n    }\n    return col;\n  };\n  var resetCache = () => _colorCache = {};\n  setColors(colors);\n\n  // public interface\n\n  const f = function (v) {\n    const c = chroma(getColor(v));\n    if (_out && c[_out]) {\n      return c[_out]();\n    } else {\n      return c;\n    }\n  };\n  f.classes = function (classes) {\n    if (classes != null) {\n      if (type(classes) === 'array') {\n        _classes = classes;\n        _domain = [classes[0], classes[classes.length - 1]];\n      } else {\n        const d = chroma.analyze(_domain);\n        if (classes === 0) {\n          _classes = [d.min, d.max];\n        } else {\n          _classes = chroma.limits(d, 'e', classes);\n        }\n      }\n      return f;\n    }\n    return _classes;\n  };\n  f.domain = function (domain) {\n    if (!arguments.length) {\n      return _domain;\n    }\n    _min = domain[0];\n    _max = domain[domain.length - 1];\n    _pos = [];\n    const k = _colors.length;\n    if (domain.length === k && _min !== _max) {\n      // update positions\n      for (let d of Array.from(domain)) {\n        _pos.push((d - _min) / (_max - _min));\n      }\n    } else {\n      for (let c = 0; c < k; c++) {\n        _pos.push(c / (k - 1));\n      }\n      if (domain.length > 2) {\n        // set domain map\n        const tOut = domain.map((d, i) => i / (domain.length - 1));\n        const tBreaks = domain.map(d => (d - _min) / (_max - _min));\n        if (!tBreaks.every((val, i) => tOut[i] === val)) {\n          tMapDomain = t => {\n            if (t <= 0 || t >= 1) return t;\n            let i = 0;\n            while (t >= tBreaks[i + 1]) i++;\n            const f = (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n            const out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n            return out;\n          };\n        }\n      }\n    }\n    _domain = [_min, _max];\n    return f;\n  };\n  f.mode = function (_m) {\n    if (!arguments.length) {\n      return _mode;\n    }\n    _mode = _m;\n    resetCache();\n    return f;\n  };\n  f.range = function (colors, _pos) {\n    setColors(colors, _pos);\n    return f;\n  };\n  f.out = function (_o) {\n    _out = _o;\n    return f;\n  };\n  f.spread = function (val) {\n    if (!arguments.length) {\n      return _spread;\n    }\n    _spread = val;\n    return f;\n  };\n  f.correctLightness = function (v) {\n    if (v == null) {\n      v = true;\n    }\n    _correctLightness = v;\n    resetCache();\n    if (_correctLightness) {\n      tMapLightness = function (t) {\n        const L0 = getColor(0, true).lab()[0];\n        const L1 = getColor(1, true).lab()[0];\n        const pol = L0 > L1;\n        let L_actual = getColor(t, true).lab()[0];\n        const L_ideal = L0 + (L1 - L0) * t;\n        let L_diff = L_actual - L_ideal;\n        let t0 = 0;\n        let t1 = 1;\n        let max_iter = 20;\n        while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n          (function () {\n            if (pol) {\n              L_diff *= -1;\n            }\n            if (L_diff < 0) {\n              t0 = t;\n              t += (t1 - t) * 0.5;\n            } else {\n              t1 = t;\n              t += (t0 - t) * 0.5;\n            }\n            L_actual = getColor(t, true).lab()[0];\n            return L_diff = L_actual - L_ideal;\n          })();\n        }\n        return t;\n      };\n    } else {\n      tMapLightness = t => t;\n    }\n    return f;\n  };\n  f.padding = function (p) {\n    if (p != null) {\n      if (type(p) === 'number') {\n        p = [p, p];\n      }\n      _padding = p;\n      return f;\n    } else {\n      return _padding;\n    }\n  };\n  f.colors = function (numColors, out) {\n    // If no arguments are given, return the original colors that were provided\n    if (arguments.length < 2) {\n      out = 'hex';\n    }\n    let result = [];\n    if (arguments.length === 0) {\n      result = _colors.slice(0);\n    } else if (numColors === 1) {\n      result = [f(0.5)];\n    } else if (numColors > 1) {\n      const dm = _domain[0];\n      const dd = _domain[1] - dm;\n      result = __range__(0, numColors, false).map(i => f(dm + i / (numColors - 1) * dd));\n    } else {\n      // returns all colors based on the defined classes\n      colors = [];\n      let samples = [];\n      if (_classes && _classes.length > 2) {\n        for (let i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n        }\n      } else {\n        samples = _domain;\n      }\n      result = samples.map(v => f(v));\n    }\n    if (chroma[out]) {\n      result = result.map(c => c[out]());\n    }\n    return result;\n  };\n  f.cache = function (c) {\n    if (c != null) {\n      _useCache = c;\n      return f;\n    } else {\n      return _useCache;\n    }\n  };\n  f.gamma = function (g) {\n    if (g != null) {\n      _gamma = g;\n      return f;\n    } else {\n      return _gamma;\n    }\n  };\n  f.nodata = function (d) {\n    if (d != null) {\n      _nacol = chroma(d);\n      return f;\n    } else {\n      return _nacol;\n    }\n  };\n  return f;\n}\nfunction __range__(left, right, inclusive) {\n  let range = [];\n  let ascending = left < right;\n  let end = !inclusive ? right : ascending ? right + 1 : right - 1;\n  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n  return range;\n}","map":{"version":3,"names":["chroma","limit","type","pow","Math","colors","_mode","_nacol","_spread","_domain","_pos","_padding","_classes","_colors","_out","_min","_max","_correctLightness","_colorCache","_useCache","_gamma","setColors","brewer","toLowerCase","length","slice","c","push","resetCache","getClass","value","n","i","tMapLightness","t","tMapDomain","getColor","val","bypassMap","col","isNaN","k","floor","p","interpolate","f","v","classes","d","analyze","min","max","limits","domain","arguments","Array","from","tOut","map","tBreaks","every","out","mode","_m","range","_o","spread","correctLightness","L0","lab","L1","pol","L_actual","L_ideal","L_diff","t0","t1","max_iter","abs","padding","numColors","result","dm","dd","__range__","samples","end","asc","cache","gamma","g","nodata","left","right","inclusive","ascending"],"sources":["/Users/alyssayee/Library/Mobile Documents/com~apple~CloudDocs/School/College/UCD/Classes/ECS 273/github/FitBot/fitbot/node_modules/chroma-js/src/generator/scale.js"],"sourcesContent":["// minimal multi-purpose interface\n\n// @requires utils color analyze\nimport chroma from '../chroma.js';\nimport { limit, type } from '../utils/index.js';\n\nconst { pow } = Math;\n\nexport default function (colors) {\n    // constructor\n    let _mode = 'rgb';\n    let _nacol = chroma('#ccc');\n    let _spread = 0;\n    // const _fixed = false;\n    let _domain = [0, 1];\n    let _pos = [];\n    let _padding = [0, 0];\n    let _classes = false;\n    let _colors = [];\n    let _out = false;\n    let _min = 0;\n    let _max = 1;\n    let _correctLightness = false;\n    let _colorCache = {};\n    let _useCache = true;\n    let _gamma = 1;\n\n    // private methods\n\n    const setColors = function (colors) {\n        colors = colors || ['#fff', '#000'];\n        if (\n            colors &&\n            type(colors) === 'string' &&\n            chroma.brewer &&\n            chroma.brewer[colors.toLowerCase()]\n        ) {\n            colors = chroma.brewer[colors.toLowerCase()];\n        }\n        if (type(colors) === 'array') {\n            // handle single color\n            if (colors.length === 1) {\n                colors = [colors[0], colors[0]];\n            }\n            // make a copy of the colors\n            colors = colors.slice(0);\n            // convert to chroma classes\n            for (let c = 0; c < colors.length; c++) {\n                colors[c] = chroma(colors[c]);\n            }\n            // auto-fill color position\n            _pos.length = 0;\n            for (let c = 0; c < colors.length; c++) {\n                _pos.push(c / (colors.length - 1));\n            }\n        }\n        resetCache();\n        return (_colors = colors);\n    };\n\n    const getClass = function (value) {\n        if (_classes != null) {\n            const n = _classes.length - 1;\n            let i = 0;\n            while (i < n && value >= _classes[i]) {\n                i++;\n            }\n            return i - 1;\n        }\n        return 0;\n    };\n\n    let tMapLightness = (t) => t;\n    let tMapDomain = (t) => t;\n\n    // const classifyValue = function(value) {\n    //     let val = value;\n    //     if (_classes.length > 2) {\n    //         const n = _classes.length-1;\n    //         const i = getClass(value);\n    //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n    //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n    //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n    //     }\n    //     return val;\n    // };\n\n    const getColor = function (val, bypassMap) {\n        let col, t;\n        if (bypassMap == null) {\n            bypassMap = false;\n        }\n        if (isNaN(val) || val === null) {\n            return _nacol;\n        }\n        if (!bypassMap) {\n            if (_classes && _classes.length > 2) {\n                // find the class\n                const c = getClass(val);\n                t = c / (_classes.length - 2);\n            } else if (_max !== _min) {\n                // just interpolate between min/max\n                t = (val - _min) / (_max - _min);\n            } else {\n                t = 1;\n            }\n        } else {\n            t = val;\n        }\n\n        // domain map\n        t = tMapDomain(t);\n\n        if (!bypassMap) {\n            t = tMapLightness(t); // lightness correction\n        }\n\n        if (_gamma !== 1) {\n            t = pow(t, _gamma);\n        }\n\n        t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n\n        t = limit(t, 0, 1);\n\n        const k = Math.floor(t * 10000);\n\n        if (_useCache && _colorCache[k]) {\n            col = _colorCache[k];\n        } else {\n            if (type(_colors) === 'array') {\n                //for i in [0.._pos.length-1]\n                for (let i = 0; i < _pos.length; i++) {\n                    const p = _pos[i];\n                    if (t <= p) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if (t >= p && i === _pos.length - 1) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if (t > p && t < _pos[i + 1]) {\n                        t = (t - p) / (_pos[i + 1] - p);\n                        col = chroma.interpolate(\n                            _colors[i],\n                            _colors[i + 1],\n                            t,\n                            _mode\n                        );\n                        break;\n                    }\n                }\n            } else if (type(_colors) === 'function') {\n                col = _colors(t);\n            }\n            if (_useCache) {\n                _colorCache[k] = col;\n            }\n        }\n        return col;\n    };\n\n    var resetCache = () => (_colorCache = {});\n\n    setColors(colors);\n\n    // public interface\n\n    const f = function (v) {\n        const c = chroma(getColor(v));\n        if (_out && c[_out]) {\n            return c[_out]();\n        } else {\n            return c;\n        }\n    };\n\n    f.classes = function (classes) {\n        if (classes != null) {\n            if (type(classes) === 'array') {\n                _classes = classes;\n                _domain = [classes[0], classes[classes.length - 1]];\n            } else {\n                const d = chroma.analyze(_domain);\n                if (classes === 0) {\n                    _classes = [d.min, d.max];\n                } else {\n                    _classes = chroma.limits(d, 'e', classes);\n                }\n            }\n            return f;\n        }\n        return _classes;\n    };\n\n    f.domain = function (domain) {\n        if (!arguments.length) {\n            return _domain;\n        }\n        _min = domain[0];\n        _max = domain[domain.length - 1];\n        _pos = [];\n        const k = _colors.length;\n        if (domain.length === k && _min !== _max) {\n            // update positions\n            for (let d of Array.from(domain)) {\n                _pos.push((d - _min) / (_max - _min));\n            }\n        } else {\n            for (let c = 0; c < k; c++) {\n                _pos.push(c / (k - 1));\n            }\n            if (domain.length > 2) {\n                // set domain map\n                const tOut = domain.map((d, i) => i / (domain.length - 1));\n                const tBreaks = domain.map((d) => (d - _min) / (_max - _min));\n                if (!tBreaks.every((val, i) => tOut[i] === val)) {\n                    tMapDomain = (t) => {\n                        if (t <= 0 || t >= 1) return t;\n                        let i = 0;\n                        while (t >= tBreaks[i + 1]) i++;\n                        const f =\n                            (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n                        const out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n                        return out;\n                    };\n                }\n            }\n        }\n        _domain = [_min, _max];\n        return f;\n    };\n\n    f.mode = function (_m) {\n        if (!arguments.length) {\n            return _mode;\n        }\n        _mode = _m;\n        resetCache();\n        return f;\n    };\n\n    f.range = function (colors, _pos) {\n        setColors(colors, _pos);\n        return f;\n    };\n\n    f.out = function (_o) {\n        _out = _o;\n        return f;\n    };\n\n    f.spread = function (val) {\n        if (!arguments.length) {\n            return _spread;\n        }\n        _spread = val;\n        return f;\n    };\n\n    f.correctLightness = function (v) {\n        if (v == null) {\n            v = true;\n        }\n        _correctLightness = v;\n        resetCache();\n        if (_correctLightness) {\n            tMapLightness = function (t) {\n                const L0 = getColor(0, true).lab()[0];\n                const L1 = getColor(1, true).lab()[0];\n                const pol = L0 > L1;\n                let L_actual = getColor(t, true).lab()[0];\n                const L_ideal = L0 + (L1 - L0) * t;\n                let L_diff = L_actual - L_ideal;\n                let t0 = 0;\n                let t1 = 1;\n                let max_iter = 20;\n                while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n                    (function () {\n                        if (pol) {\n                            L_diff *= -1;\n                        }\n                        if (L_diff < 0) {\n                            t0 = t;\n                            t += (t1 - t) * 0.5;\n                        } else {\n                            t1 = t;\n                            t += (t0 - t) * 0.5;\n                        }\n                        L_actual = getColor(t, true).lab()[0];\n                        return (L_diff = L_actual - L_ideal);\n                    })();\n                }\n                return t;\n            };\n        } else {\n            tMapLightness = (t) => t;\n        }\n        return f;\n    };\n\n    f.padding = function (p) {\n        if (p != null) {\n            if (type(p) === 'number') {\n                p = [p, p];\n            }\n            _padding = p;\n            return f;\n        } else {\n            return _padding;\n        }\n    };\n\n    f.colors = function (numColors, out) {\n        // If no arguments are given, return the original colors that were provided\n        if (arguments.length < 2) {\n            out = 'hex';\n        }\n        let result = [];\n\n        if (arguments.length === 0) {\n            result = _colors.slice(0);\n        } else if (numColors === 1) {\n            result = [f(0.5)];\n        } else if (numColors > 1) {\n            const dm = _domain[0];\n            const dd = _domain[1] - dm;\n            result = __range__(0, numColors, false).map((i) =>\n                f(dm + (i / (numColors - 1)) * dd)\n            );\n        } else {\n            // returns all colors based on the defined classes\n            colors = [];\n            let samples = [];\n            if (_classes && _classes.length > 2) {\n                for (\n                    let i = 1, end = _classes.length, asc = 1 <= end;\n                    asc ? i < end : i > end;\n                    asc ? i++ : i--\n                ) {\n                    samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n                }\n            } else {\n                samples = _domain;\n            }\n            result = samples.map((v) => f(v));\n        }\n\n        if (chroma[out]) {\n            result = result.map((c) => c[out]());\n        }\n        return result;\n    };\n\n    f.cache = function (c) {\n        if (c != null) {\n            _useCache = c;\n            return f;\n        } else {\n            return _useCache;\n        }\n    };\n\n    f.gamma = function (g) {\n        if (g != null) {\n            _gamma = g;\n            return f;\n        } else {\n            return _gamma;\n        }\n    };\n\n    f.nodata = function (d) {\n        if (d != null) {\n            _nacol = chroma(d);\n            return f;\n        } else {\n            return _nacol;\n        }\n    };\n\n    return f;\n}\n\nfunction __range__(left, right, inclusive) {\n    let range = [];\n    let ascending = left < right;\n    let end = !inclusive ? right : ascending ? right + 1 : right - 1;\n    for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n        range.push(i);\n    }\n    return range;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}