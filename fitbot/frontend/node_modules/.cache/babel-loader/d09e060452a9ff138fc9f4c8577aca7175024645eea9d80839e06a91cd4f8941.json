{"ast":null,"code":"import type from './type.js';\nconst {\n  log,\n  pow,\n  floor,\n  abs\n} = Math;\nexport function analyze(data, key = null) {\n  const r = {\n    min: Number.MAX_VALUE,\n    max: Number.MAX_VALUE * -1,\n    sum: 0,\n    values: [],\n    count: 0\n  };\n  if (type(data) === 'object') {\n    data = Object.values(data);\n  }\n  data.forEach(val => {\n    if (key && type(val) === 'object') val = val[key];\n    if (val !== undefined && val !== null && !isNaN(val)) {\n      r.values.push(val);\n      r.sum += val;\n      if (val < r.min) r.min = val;\n      if (val > r.max) r.max = val;\n      r.count += 1;\n    }\n  });\n  r.domain = [r.min, r.max];\n  r.limits = (mode, num) => limits(r, mode, num);\n  return r;\n}\nexport function limits(data, mode = 'equal', num = 7) {\n  if (type(data) == 'array') {\n    data = analyze(data);\n  }\n  const {\n    min,\n    max\n  } = data;\n  const values = data.values.sort((a, b) => a - b);\n  if (num === 1) {\n    return [min, max];\n  }\n  const limits = [];\n  if (mode.substr(0, 1) === 'c') {\n    // continuous\n    limits.push(min);\n    limits.push(max);\n  }\n  if (mode.substr(0, 1) === 'e') {\n    // equal interval\n    limits.push(min);\n    for (let i = 1; i < num; i++) {\n      limits.push(min + i / num * (max - min));\n    }\n    limits.push(max);\n  } else if (mode.substr(0, 1) === 'l') {\n    // log scale\n    if (min <= 0) {\n      throw new Error('Logarithmic scales are only possible for values > 0');\n    }\n    const min_log = Math.LOG10E * log(min);\n    const max_log = Math.LOG10E * log(max);\n    limits.push(min);\n    for (let i = 1; i < num; i++) {\n      limits.push(pow(10, min_log + i / num * (max_log - min_log)));\n    }\n    limits.push(max);\n  } else if (mode.substr(0, 1) === 'q') {\n    // quantile scale\n    limits.push(min);\n    for (let i = 1; i < num; i++) {\n      const p = (values.length - 1) * i / num;\n      const pb = floor(p);\n      if (pb === p) {\n        limits.push(values[pb]);\n      } else {\n        // p > pb\n        const pr = p - pb;\n        limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n      }\n    }\n    limits.push(max);\n  } else if (mode.substr(0, 1) === 'k') {\n    // k-means clustering\n    /*\n    implementation based on\n    http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n    simplified for 1-d input values\n    */\n    let cluster;\n    const n = values.length;\n    const assignments = new Array(n);\n    const clusterSizes = new Array(num);\n    let repeat = true;\n    let nb_iters = 0;\n    let centroids = null;\n\n    // get seed values\n    centroids = [];\n    centroids.push(min);\n    for (let i = 1; i < num; i++) {\n      centroids.push(min + i / num * (max - min));\n    }\n    centroids.push(max);\n    while (repeat) {\n      // assignment step\n      for (let j = 0; j < num; j++) {\n        clusterSizes[j] = 0;\n      }\n      for (let i = 0; i < n; i++) {\n        const value = values[i];\n        let mindist = Number.MAX_VALUE;\n        let best;\n        for (let j = 0; j < num; j++) {\n          const dist = abs(centroids[j] - value);\n          if (dist < mindist) {\n            mindist = dist;\n            best = j;\n          }\n          clusterSizes[best]++;\n          assignments[i] = best;\n        }\n      }\n\n      // update centroids step\n      const newCentroids = new Array(num);\n      for (let j = 0; j < num; j++) {\n        newCentroids[j] = null;\n      }\n      for (let i = 0; i < n; i++) {\n        cluster = assignments[i];\n        if (newCentroids[cluster] === null) {\n          newCentroids[cluster] = values[i];\n        } else {\n          newCentroids[cluster] += values[i];\n        }\n      }\n      for (let j = 0; j < num; j++) {\n        newCentroids[j] *= 1 / clusterSizes[j];\n      }\n\n      // check convergence\n      repeat = false;\n      for (let j = 0; j < num; j++) {\n        if (newCentroids[j] !== centroids[j]) {\n          repeat = true;\n          break;\n        }\n      }\n      centroids = newCentroids;\n      nb_iters++;\n      if (nb_iters > 200) {\n        repeat = false;\n      }\n    }\n\n    // finished k-means clustering\n    // the next part is borrowed from gabrielflor.it\n    const kClusters = {};\n    for (let j = 0; j < num; j++) {\n      kClusters[j] = [];\n    }\n    for (let i = 0; i < n; i++) {\n      cluster = assignments[i];\n      kClusters[cluster].push(values[i]);\n    }\n    let tmpKMeansBreaks = [];\n    for (let j = 0; j < num; j++) {\n      tmpKMeansBreaks.push(kClusters[j][0]);\n      tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);\n    }\n    tmpKMeansBreaks = tmpKMeansBreaks.sort((a, b) => a - b);\n    limits.push(tmpKMeansBreaks[0]);\n    for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {\n      const v = tmpKMeansBreaks[i];\n      if (!isNaN(v) && limits.indexOf(v) === -1) {\n        limits.push(v);\n      }\n    }\n  }\n  return limits;\n}","map":{"version":3,"names":["type","log","pow","floor","abs","Math","analyze","data","key","r","min","Number","MAX_VALUE","max","sum","values","count","Object","forEach","val","undefined","isNaN","push","domain","limits","mode","num","sort","a","b","substr","i","Error","min_log","LOG10E","max_log","p","length","pb","pr","cluster","n","assignments","Array","clusterSizes","repeat","nb_iters","centroids","j","value","mindist","best","dist","newCentroids","kClusters","tmpKMeansBreaks","v","indexOf"],"sources":["/Users/alyssayee/Library/Mobile Documents/com~apple~CloudDocs/School/College/UCD/Classes/ECS 273/github/FitBot/fitbot/node_modules/chroma-js/src/utils/analyze.js"],"sourcesContent":["import type from './type.js';\n\nconst { log, pow, floor, abs } = Math;\n\nexport function analyze(data, key = null) {\n    const r = {\n        min: Number.MAX_VALUE,\n        max: Number.MAX_VALUE * -1,\n        sum: 0,\n        values: [],\n        count: 0\n    };\n    if (type(data) === 'object') {\n        data = Object.values(data);\n    }\n    data.forEach((val) => {\n        if (key && type(val) === 'object') val = val[key];\n        if (val !== undefined && val !== null && !isNaN(val)) {\n            r.values.push(val);\n            r.sum += val;\n            if (val < r.min) r.min = val;\n            if (val > r.max) r.max = val;\n            r.count += 1;\n        }\n    });\n\n    r.domain = [r.min, r.max];\n\n    r.limits = (mode, num) => limits(r, mode, num);\n\n    return r;\n}\n\nexport function limits(data, mode = 'equal', num = 7) {\n    if (type(data) == 'array') {\n        data = analyze(data);\n    }\n    const { min, max } = data;\n    const values = data.values.sort((a, b) => a - b);\n\n    if (num === 1) {\n        return [min, max];\n    }\n\n    const limits = [];\n\n    if (mode.substr(0, 1) === 'c') {\n        // continuous\n        limits.push(min);\n        limits.push(max);\n    }\n\n    if (mode.substr(0, 1) === 'e') {\n        // equal interval\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            limits.push(min + (i / num) * (max - min));\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'l') {\n        // log scale\n        if (min <= 0) {\n            throw new Error(\n                'Logarithmic scales are only possible for values > 0'\n            );\n        }\n        const min_log = Math.LOG10E * log(min);\n        const max_log = Math.LOG10E * log(max);\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            limits.push(pow(10, min_log + (i / num) * (max_log - min_log)));\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'q') {\n        // quantile scale\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            const p = ((values.length - 1) * i) / num;\n            const pb = floor(p);\n            if (pb === p) {\n                limits.push(values[pb]);\n            } else {\n                // p > pb\n                const pr = p - pb;\n                limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n            }\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'k') {\n        // k-means clustering\n        /*\n        implementation based on\n        http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n        simplified for 1-d input values\n        */\n        let cluster;\n        const n = values.length;\n        const assignments = new Array(n);\n        const clusterSizes = new Array(num);\n        let repeat = true;\n        let nb_iters = 0;\n        let centroids = null;\n\n        // get seed values\n        centroids = [];\n        centroids.push(min);\n        for (let i = 1; i < num; i++) {\n            centroids.push(min + (i / num) * (max - min));\n        }\n        centroids.push(max);\n\n        while (repeat) {\n            // assignment step\n            for (let j = 0; j < num; j++) {\n                clusterSizes[j] = 0;\n            }\n            for (let i = 0; i < n; i++) {\n                const value = values[i];\n                let mindist = Number.MAX_VALUE;\n                let best;\n                for (let j = 0; j < num; j++) {\n                    const dist = abs(centroids[j] - value);\n                    if (dist < mindist) {\n                        mindist = dist;\n                        best = j;\n                    }\n                    clusterSizes[best]++;\n                    assignments[i] = best;\n                }\n            }\n\n            // update centroids step\n            const newCentroids = new Array(num);\n            for (let j = 0; j < num; j++) {\n                newCentroids[j] = null;\n            }\n            for (let i = 0; i < n; i++) {\n                cluster = assignments[i];\n                if (newCentroids[cluster] === null) {\n                    newCentroids[cluster] = values[i];\n                } else {\n                    newCentroids[cluster] += values[i];\n                }\n            }\n            for (let j = 0; j < num; j++) {\n                newCentroids[j] *= 1 / clusterSizes[j];\n            }\n\n            // check convergence\n            repeat = false;\n            for (let j = 0; j < num; j++) {\n                if (newCentroids[j] !== centroids[j]) {\n                    repeat = true;\n                    break;\n                }\n            }\n\n            centroids = newCentroids;\n            nb_iters++;\n\n            if (nb_iters > 200) {\n                repeat = false;\n            }\n        }\n\n        // finished k-means clustering\n        // the next part is borrowed from gabrielflor.it\n        const kClusters = {};\n        for (let j = 0; j < num; j++) {\n            kClusters[j] = [];\n        }\n        for (let i = 0; i < n; i++) {\n            cluster = assignments[i];\n            kClusters[cluster].push(values[i]);\n        }\n        let tmpKMeansBreaks = [];\n        for (let j = 0; j < num; j++) {\n            tmpKMeansBreaks.push(kClusters[j][0]);\n            tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);\n        }\n        tmpKMeansBreaks = tmpKMeansBreaks.sort((a, b) => a - b);\n        limits.push(tmpKMeansBreaks[0]);\n        for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {\n            const v = tmpKMeansBreaks[i];\n            if (!isNaN(v) && limits.indexOf(v) === -1) {\n                limits.push(v);\n            }\n        }\n    }\n    return limits;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}